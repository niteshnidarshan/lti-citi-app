package app.lti.citi.transaction.lticitiapptransaction.service;

import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired; 
import org.springframework.stereotype.Service;
 
import app.lti.citi.transaction.lticitiapptransaction.dao.TransactionRepository;
import app.lti.citi.transaction.lticitiapptransaction.document.TransactionDetail;
import app.lti.citi.transaction.lticitiapptransaction.dto.AccountDetailDto;
import app.lti.citi.transaction.lticitiapptransaction.dto.TransactionDetailDto;
import app.lti.citi.transaction.lticitiapptransaction.dto.TransactionStatus;
import app.lti.citi.transaction.lticitiapptransaction.dto.TransactionType; 
import app.lti.citi.transaction.lticitiapptransaction.feignproxy.AccountFeignProxy;
import app.lti.citi.transaction.lticitiapptransaction.thread.ReceiverAmount;
import app.lti.citi.transaction.lticitiapptransaction.thread.SenderAmount;
import app.lti.citi.transaction.lticitiapptransaction.thread.UpdateSenderAmount;

@Service
public class TransactionServiceImpl implements TransactionService{ 
	
	private static final Logger logger = LoggerFactory.getLogger(TransactionServiceImpl.class);
	
	@Autowired
	private AccountFeignProxy accountProxy;
	
	@Autowired
	private TransactionRepository repository;
	
	@Autowired
	private ObjectConvertor convertor;

	@Override
	public TransactionDetailDto transferAmount(TransactionDetailDto transactionDetailDto) throws Exception {
		
		/**
		 * Steps to follow in tranfer amount
		 * 1) check request is not null
		 * 2) fetch amount from sender's accountId
		 * 3) fetch amount from receiver's accountId
		 * 4) minus requested amount from sender's amount
		 * 5) add requested amount to receiver's amount
		 * 6) update minus amount to sender's account
		 * 7) update added amount to receiver's account
		 * 8) construct TransactionDetailDto with status = SUCCESS/ FAILURE 
		 * 9) return inserted TransactionDetail
		 * 
		 * 10) For step 2 to 7 create 5 Callable type classes
		 * 11) execute step 2 to 7 in same order with an atomic operation by imposing a lock. 
		 */
		
		TransactionDetailDto dto = null;
		
		if(transactionDetailDto != null) {
			
			ExecutorService executor = Executors.newFixedThreadPool(1); 

			Lock lock = new ReentrantLock(true);
			lock.lock(); 
			
			double amountToBeTransfered = transactionDetailDto.getAmount();
			
			//For rollback purpose
			Double senders_total_amount_rollback;
			Double receivers_total_amount_rollback;
			
			try {
				
				//Fetch total amounts of source & target accounts
				Future<Double> senderAmount = executor.submit(new SenderAmount(transactionDetailDto.getSenderAccountId(), accountProxy));
				Future<Double> receiverAmount = executor.submit(new ReceiverAmount(transactionDetailDto.getReceiversAccountId(), accountProxy));
				 
				Double senders_total_amount = senderAmount.get();
				Double receivers_total_amount = receiverAmount.get(); 

				//Retain values for rollback in case transaction failure
				senders_total_amount_rollback = senders_total_amount;
				receivers_total_amount_rollback = receivers_total_amount;
				
				if(amountToBeTransfered > 0) {
					try {
						//Calculate final amount
						senders_total_amount = senders_total_amount - amountToBeTransfered;
						receivers_total_amount = receivers_total_amount + amountToBeTransfered;
						
						//call update thread for both source & target account with updated account to the respective accounts
						Future<AccountDetailDto> senderAccount = executor.submit(new UpdateSenderAmount(transactionDetailDto.getSenderAccountId(), senders_total_amount, accountProxy));
						Future<AccountDetailDto> receiverAccount = executor.submit(new UpdateSenderAmount(transactionDetailDto.getReceiversAccountId(), receivers_total_amount, accountProxy));

						AccountDetailDto senderDto = senderAccount.get();
						AccountDetailDto receiverDto = receiverAccount.get();
						
						if(senderDto != null && receiverDto != null) {
							//return success status
							TransactionDetail transaction = new TransactionDetail();
							transaction.setTransactionId(null); //will be generated by db
							transaction.setSenderAccountId(transactionDetailDto.getSenderAccountId());
							transaction.setReceiversAccountId(transactionDetailDto.getReceiversAccountId());
							transaction.setAmount(transactionDetailDto.getAmount());
							transaction.setAssociatedUserId(transactionDetailDto.getAssociatedUserId());
							transaction.setTransactionType(TransactionType.DIGITAL);
							transaction.setTransactionStatus(TransactionStatus.SUCCESS);
							transaction.setTransactionTimeStamp(new Date(System.currentTimeMillis()));
							
							//save this transaction to db 
							transaction = this.repository.save(transaction);
							if(transaction != null) {
								dto = this.convertor.actualToDto(transaction);
								logger.info("Transaction Success!");
							}
						}
						
					}catch(Exception ex) {
						//rollback process
						Future<AccountDetailDto> senderAccount = executor.submit(new UpdateSenderAmount(transactionDetailDto.getSenderAccountId(), senders_total_amount_rollback, accountProxy));
						Future<AccountDetailDto> receiverAccount = executor.submit(new UpdateSenderAmount(transactionDetailDto.getReceiversAccountId(), receivers_total_amount_rollback, accountProxy));

						AccountDetailDto senderDto = senderAccount.get();
						AccountDetailDto receiverDto = receiverAccount.get();
						
						if(senderDto != null && receiverDto != null) {
							//return success status
							TransactionDetail transaction = new TransactionDetail();
							transaction.setTransactionId(null); //will be generated by db
							transaction.setSenderAccountId(transactionDetailDto.getSenderAccountId());
							transaction.setReceiversAccountId(transactionDetailDto.getReceiversAccountId());
							transaction.setAmount(transactionDetailDto.getAmount());
							transaction.setAssociatedUserId(transactionDetailDto.getAssociatedUserId());
							transaction.setTransactionType(TransactionType.DIGITAL);
							transaction.setTransactionStatus(TransactionStatus.FAILED);
							transaction.setTransactionTimeStamp(new Date(System.currentTimeMillis()));
							
							//save this transaction to db 
							transaction = this.repository.save(transaction);
							if(transaction != null) {
								dto = this.convertor.actualToDto(transaction);
								logger.info("Transaction Failed & rollbacked!");
								logger.error("Exception during transaction "+ex.getMessage());
							}
						}
						
						throw ex;
					}
					
				}
				
				
				
			}catch(Exception ex) { 
				logger.error("Exception in main try block ... "+ex.getMessage());
				throw ex; 
			}finally {
				//release lock
				if(lock != null)
					lock.unlock();
				
				logger.info("Transaction lock released!");
			}
			
		}
		
		return dto;
	}

	@Override
	public List<TransactionDetailDto> getAllTransaction(String associatedUserId) throws Exception {

		List<TransactionDetailDto> dtoList = new LinkedList<>();
		
		try {
			if(associatedUserId != null) {
				this.repository.findAllByAssociatedUserId(associatedUserId).forEach((transaction) -> {
					if(transaction != null) {
						TransactionDetailDto dto = this.convertor.actualToDto(transaction);
						dtoList.add(dto);
					}
				});
			}
		}catch(Exception ex) {
			logger.error("Exception during fetch of all transaction record of user = "+associatedUserId+"  | "+ex.getMessage());
			throw ex; 
		}
		
		return dtoList;

	}
	
	@Override
	public Double getAmount(String sendersAccountId) {
		return this.accountProxy.getAmount(sendersAccountId).getBody();
	}
	
	

}
